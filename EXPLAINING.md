# Три ключевых момента в коде.  


## Первый:  
```swift
enum Speaker {
    case ...
    
    enum Params {
        case ...
    }
    
    enum SexType: String {
        ...
    }
    
	var details: String {
        ...
    }
}
```

Перечисления (Enum) в Swift позволяют объявлять вложенные (Nested) разные типы данных, даже другие перечисления (Enum). Всегда стоит держать в голове, что вложенные типы не являются корневыми типами и при сравнении корневого и вложенного всегда будет отрицательный результат.

К примеру, это очень важно при проектировании сущностей (Entities) для работы с сервером. Используя такие вложения может возникнуть желание сравнить:

```swift
let value1 = Speaker.SexType.girl
let value2 = Speaker.Params.sex(.girl)

let compare = value1 == value2
```

результат такого сравнения вернет ошибку:

> Binary operator '==' cannot be applied to operands of type 'Speaker.SexType' and 'Speaker.Params'

что говорит нам о различии типов параметров.


## Второй:  

Структуры в Swift являются "Value type". При передаче экземпляра структуры, к примеру в метод, будет передано значение, а не ссылка на него.

```swift
struct Somebody {
    
    let name: String
    
    mutating func set(name: String) {
        ...
    }
}
```

Чтобы изменять константные значения в структуре, можно использовать методы с модификатором мутации (mutating). Результат выполения такого метода пересоздаст экземпляр структуры. Это важно помнить при работе со структурой используя доступ по ссылке.


## Третий:  

Опциональные типы данных (Optionals) имеют возможность доступа к значению без предварительной распаковки (Unwrapping). Это очень удобно в целях читаемости кода.

```swift
let value10 = FirstChain(value: SecondChain(value: ThirdChain(name: "Kirill")))
value10.value?.value?.name		// значение: "Kirill"

let value11 = FirstChain(value: nil)
value11.value?.value?.name		// значение nil
```

Важно помнить, что в длительных цепочках значение nil может быть взято с любого уровня цепи. Использование длительных цепочек может сильно затруднить отладку (Debug).